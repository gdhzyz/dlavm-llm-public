from time import strftime, localtime
from .. import ne


class CodeGenCSBHead:

    ddr_base_addr = 0x200000000
    hbm_base_addr = 0x000000000
    tab = "  "

    def ext_define(self):
        pass

    def build(self, mod_name: str, module, storage, device=None):
        self.func_input = []
        self.func_output = []
        self.func_const_hbm = []
        self.func_const_ddr = []
        self.func_body = []
        self.enum_nodes = [[], [], [], []]
        self.dynamic_var = []
        self.ext_define()
        self.mod_name = mod_name
        self.storage = storage
        self.device = device
        for node in module:
            if node["node"] == "var":
                self.gen_var(node)
            elif node["node"] == "output":
                self.gen_output(node)
            elif node["node"] == "const":
                self.gen_const(node)
            elif node["node"] == "accel_op":
                self.gen_accel(node)
            elif node["node"] == "cpu_op":
                self.gen_cpu(node)
            elif node["node"] == "virtual_op":
                self.gen_virtual(node)
            else:
                print("unkonwn node of module: ", node["node"])
                exit(-1)
        return self.gen_source()

    def to_string(self):
        enum_input_str = "enum InputNode{\n" + ",\n".join([self.tab + node for node in self.enum_nodes[0]]) + "\n};"
        enum_output_str = "enum OutputNode{\n" + ",\n".join([self.tab + node for node in self.enum_nodes[1]]) + "\n};"
        enum_wtddr_str = "enum WtDDRNode{\n" + ",\n".join([self.tab + node for node in self.enum_nodes[2]]) + "\n};"
        enum_wthbm_str = "enum WtHBMNode{\n" + ",\n".join([self.tab + node for node in self.enum_nodes[3]]) + "\n};"
        self.enum_define_str = "\n".join([enum_input_str, enum_output_str, enum_wtddr_str, enum_wthbm_str])
        self.func_init_str = ""
        self.func_input_str = "\n".join(self.func_input)
        self.func_wtddr_str = "\n".join(self.func_const_ddr)
        self.func_wthbm_str = "\n".join(self.func_const_hbm)
        self.func_output_str = "\n".join(self.func_output)
        self.func_body_str = "\n".join(self.func_body)
        self.storages_str = self.storage.gen_source()
        self.mod_args = ", ".join(["HANDLE device"] + self.dynamic_var)

    def gen_source(self):
        local_time = strftime('%Y-%m-%d %H:%M:%S', localtime())
        self.to_string()
        source_map = {
            "local_time": local_time, "enum_define": self.enum_define_str, "func_input": self.func_input_str,
            "func_const_ddr": self.func_wtddr_str, "func_const_hbm": self.func_wthbm_str, "tab": self.tab,
            "func_output": self.func_output_str, "func_body": self.func_body_str, "mod_name": self.mod_name,
            "storages": self.storages_str, "mod_args": self.mod_args, "func_init": self.func_init_str,
        }
        source = """// generated by codegen c++ csb head at %(local_time)s
%(storages)s

// module enum define, %(mod_name)sNode::enum
struct %(mod_name)sNode {
%(enum_define)s
};

// get input ptr
void* GetInputPtr(enum %(mod_name)sNode::InputNode node) {
%(tab)sswitch (node) {
%(func_input)s
%(tab)sdefault: printf("Error! Not input node, please check!");
%(tab)s%(tab)sexit(-1); return (void*)0;
%(tab)s}
}

// get output ptr
void* GetOutputPtr(enum %(mod_name)sNode::OutputNode node) {
%(tab)sswitch (node) {
%(func_output)s
%(tab)sdefault: printf("Error! Not output node, please check!");
%(tab)s%(tab)sexit(-1); return (void*)0;
%(tab)s}
}

// get weight ddr ptr
void* GetWeightDDRPtr(enum %(mod_name)sNode::WtDDRNode node) {
%(tab)sswitch (node) {
%(func_const_ddr)s
%(tab)sdefault: printf("Error! Not weight node, please check!");
%(tab)s%(tab)sexit(-1); return (void*)0;
%(tab)s}
}

// get weight hbm ptr
void* GetWeightHBMPtr(enum %(mod_name)sNode::WtHBMNode node) {
%(tab)sswitch (node) {
%(func_const_hbm)s
%(tab)sdefault: printf("Error! Not weight node, please check!");
%(tab)s%(tab)sexit(-1); return (void*)0;
%(tab)s}
}

// mod init
%(func_init)s

void %(mod_name)s(%(mod_args)s) {
#ifdef REGS_DEBUG
LARGE_INTEGER start_cfg;
LARGE_INTEGER stop_cfg;
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
double time_sec1;
QueryPerformanceFrequency(&freq);
#endif
%(func_body)s
}
""" % source_map
        return source

    def gen_var(self, node):
        enum_name = node["name"]
        id, offset = node["storage"][0]["id"], node["storage"][0]["offset"]
        self.func_input.append(f"{self.tab}case {self.mod_name}Node::{enum_name}:")
        self.func_input.append(f"{self.tab}{self.tab}return (void*)(&{id}[{offset}]);")
        if enum_name in self.enum_nodes[0] + self.enum_nodes[2] + self.enum_nodes[3]:
            print("*WARNING* : Var或Const节点中存在同名元素，请检查")
            exit(-1)
        else:
            self.enum_nodes[0].append(enum_name)
        for n in node["shape"]:
            if isinstance(n, ne.Expr):
                vars = n.get_vars()
                for var in vars:
                    source = f"int {var[0]}"
                    if source not in self.dynamic_var:
                        self.dynamic_var.append(source)

    def gen_output(self, node):
        enum_name = node["name"]
        id, offset = node["storage"][0]["id"], node["storage"][0]["offset"]
        self.func_output.append(f"{self.tab}case {self.mod_name}Node::{enum_name}:")
        self.func_output.append(f"{self.tab}{self.tab}return (void*)(&{id}[{offset}]);")
        self.enum_nodes[1].append(enum_name)

    def gen_const(self, node):
        enum_name = node["name"]
        id, offset = node["storage"][0]["id"], node["storage"][0]["offset"]
        if enum_name in self.enum_nodes[0] + self.enum_nodes[2] + self.enum_nodes[3]:
            print("*WARNING* : Var或Const节点中存在同名元素，请检查")
            exit(-1)
        if id[:3] == "hbm":
            self.func_const_hbm.append(f"{self.tab}case {self.mod_name}Node::{enum_name}:")
            self.func_const_hbm.append(f"{self.tab}{self.tab}return (void*)(&{id}[{offset}]);")
            self.enum_nodes[3].append(enum_name)
        else:
            self.func_const_ddr.append(f"{self.tab}case {self.mod_name}Node::{enum_name}:")
            self.func_const_ddr.append(f"{self.tab}{self.tab}return (void*)(&{id}[{offset}]);")
            self.enum_nodes[2].append(enum_name)
        for n in node["shape"]:
            if isinstance(n, ne.Expr):
                vars = n.get_vars()
                for var in vars:
                    source = f"int {var[0]}"
                    if source not in self.dynamic_var:
                        self.dynamic_var.append(source)

    def gen_accel(self, node):
        op_name, ddr_id, offset = node["op_name"], node["storage"][0]["id"], node["storage"][0]["offset"]
        self.func_body.append(f"// {op_name} accel operator node, storage data in {ddr_id} with {offset} offset")
        cfg_start = 1
        for reg in node["csb_regs"]:
            if reg[0] == 1:
                if cfg_start:
                    self.func_body.append("""#ifdef REGS_DEBUG
QueryPerformanceCounter(&start_cfg);
#endif""")
                    cfg_start = 0
                data = reg[2]
                if isinstance(reg[2], ne.Expr):
                    for var in reg[2].get_vars():
                        source = f"int {var[0]}"
                        if source not in self.dynamic_var:
                            self.dynamic_var.append(source)
                    data = reg[2].export("cpp")
                self.func_body.append(f"{self.tab}CSB_Write(device, {reg[1]}, {data});")
            elif reg[0] == 0:
                cfg_start = 1
                self.func_body.append("""#ifdef REGS_DEBUG
QueryPerformanceCounter(&stop_cfg);
QueryPerformanceCounter(&start_run);
#endif""")
                self.func_body.append(f"{self.tab}while(CSB_Read(device, {reg[1]}) != {reg[2]}) " + "{}")
                self.func_body.append("""#ifdef REGS_DEBUG
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_cfg.QuadPart - start_cfg.QuadPart) / (double)freq.QuadPart;
time_sec1 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("%(op_name)s cfg reg time = %%fs \\n",time_sec0);
printf("%(op_name)s run time     = %%fs \\n",time_sec1);
#endif""" % {"op_name": op_name})

    def gen_cpu(self, node):
        op_name = node["op_name"]
        self.func_body.append(f"// {op_name} accel operator node")
        for code in node["source"]:
            self.func_body.append(f"{self.tab}{code}")

    def gen_virtual(self, node):
        pass

