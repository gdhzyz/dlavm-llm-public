import numpy as np
from .codegen_csb_head import CodeGenCSBHead
from time import strftime, localtime
from ..adr import Op, DataEnum
from .. import ne


class CodeGenTestHead(CodeGenCSBHead):

    def ext_define(self):
        super().ext_define()
        self.init_weight = []

    def to_string(self):
        super().to_string()
        self.func_init_str += f"void {self.mod_name}_load_params(HANDLE device, HANDLE h2cx)" + " {\n" + "\n".join(self.init_weight) + "\n}\n"

    def gen_var(self, node):
        enum_name = node["name"]
        id, offset = node["storage"][0]["id"], node["storage"][0]["offset"]
        address = self.storage.get_address(id, offset, self.ddr_base_addr)
        self.func_input.append("uint64_t %s = 0x%09x; // %d" % (enum_name, address, address & 0xffffffff))
        if enum_name in self.enum_nodes[0] + self.enum_nodes[2] + self.enum_nodes[3]:
            print("*WARNING* : Var或Const节点中存在同名元素，请检查")
            exit(-1)
        else:
            self.enum_nodes[0].append(enum_name)
        for n in node["shape"]:
            if isinstance(n, ne.Expr):
                vars = n.get_vars()
                for var in vars:
                    source = f"int {var[0]}"
                    if source not in self.dynamic_var:
                        self.dynamic_var.append(source)

    def gen_output(self, node):
        enum_name = node["name"]
        id, offset = node["storage"][0]["id"], node["storage"][0]["offset"]
        address = self.storage.get_address(id, offset, self.ddr_base_addr)
        self.func_output.append("uint64_t %s = 0x%09x; // %d" % (enum_name, address, address & 0xffffffff))
        self.enum_nodes[1].append(enum_name)

    def gen_const(self, node):
        enum_name, data, dtype = node["name"], node.get("data", None), node["dtype"]
        id, offset = node["storage"][0]["id"], node["storage"][0]["offset"]
        byte_size = self.storage.get_byte_size(id)
        if enum_name in self.enum_nodes[0] + self.enum_nodes[2] + self.enum_nodes[3]:
            print("*WARNING* : Var或Const节点中存在同名元素，请检查")
            exit(-1)
        if dtype.mapped == DataEnum.hbm:
            address = self.storage.get_address(id, offset)
            self.func_const_hbm.append("uint64_t %s = 0x%09x; // %d" % (enum_name, address, address & 0xffffffff))
            self.enum_nodes[3].append(enum_name)
            if isinstance(data, str):
                for i in range(self.device.HBM_Port):
                    fpath = data % i
                    real_address = address + i*(1 << self.device.log2_Bank_Step)
                    self.init_weight.append(f"{self.tab}DDR_Write_bin(h2cx, \"{fpath}\", {real_address}, {byte_size});")
        elif dtype.mapped == DataEnum.ddr:
            address = self.storage.get_address(id, offset, self.ddr_base_addr)
            self.func_const_ddr.append("uint64_t %s = 0x%09x; // %d" % (enum_name, address, address & 0xffffffff))
            self.enum_nodes[2].append(enum_name)
            if isinstance(data, str):
                self.init_weight.append(f"{self.tab}DDR_Write_bin(h2cx, \"{data}\", {address}, {byte_size});")
        else:
            raise RuntimeError(f"Unknown dtype for constant: {dtype.mapped}")
        for n in node["shape"]:
            if isinstance(n, ne.Expr):
                vars = n.get_vars()
                for var in vars:
                    source = f"int {var[0]}"
                    if source not in self.dynamic_var:
                        self.dynamic_var.append(source)

    def gen_source(self):
        local_time = strftime('%Y-%m-%d %H:%M:%S', localtime())
        self.to_string()
        source_map = {
            "local_time": local_time, "enum_define": self.enum_define_str, "func_input": self.func_input_str,
            "func_const_ddr": self.func_wtddr_str, "func_const_hbm": self.func_wthbm_str, "tab": self.tab,
            "func_output": self.func_output_str, "func_body": self.func_body_str, "mod_name": self.mod_name,
            "storages": self.storages_str, "mod_args": self.mod_args, "func_init": self.func_init_str,
        }
        source = """// generated by codegen c++ csb head at %(local_time)s
%(storages)s

// get input ptr
%(func_input)s

// get output ptr
%(func_output)s

// get weight ddr ptr
%(func_const_ddr)s

// get weight hbm ptr
%(func_const_hbm)s

// mod init
%(func_init)s

void %(mod_name)s(%(mod_args)s) {
#ifdef REGS_DEBUG
LARGE_INTEGER start_cfg;
LARGE_INTEGER stop_cfg;
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
double time_sec1;
QueryPerformanceFrequency(&freq);
#endif
%(func_body)s
}
""" % source_map
        return source
